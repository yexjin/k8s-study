# 쿠버네티스

### 쿠버네티스 클러스터

---

- 여러 대의 서버 또는 가상 머신으로 구성된 컴퓨팅 자원의 집합
- 컨테이너화된 애플리케이션을 실행하고 관리하는 데 사용
- 마스터 노드와 워커 노드로 구성
- **마스터 노드**
  - 클러스터 전체를 제어하는 Control Plane을 담당
  - API 서버, 스케줄러, 컨트롤러 매니저 등의 구성요소로 구성됨
- **워커 노드**
  - 컨테이너를 실행하는 노드
  - 런타임과 컨테이너화된 애플리케이션을 실행하기 위한 다른 구성 요소들을 가지고 있다.

<br>
<br>

### 컨트롤 플레인

---

- 마스터 노드에 의해 실행되며 클러스터를 제어하고 작동시킨다.

**구성요소**

1. `API 서버` : 사용자, 컨트롤 플레인 구성요소와 통신
2. `스케줄러` : 애플리케이션의 배포를 담당 (애플리케이션의 배포 가능한 각 구성 요소를 워커 노드에 할당)
3. `컨트롤러 매니저` : 구성요소의 복제본, 워커 노드 추적, 노드 장애 처리 등과 같은 클러스터단의 기능 수행
4. `Etcd` : 클러스터 구성을 지속적으로 저장하는 신뢰할 수 있는 분산 데이터 저장소

<br>
<br>

### (워커) 노드

---

- 컨테이너화된 애플리케이션을 실행하는 시스템

**구성요소**

1. 컨테이너를 실행하는 `**도커, rkt**` 또는 다른 컨테이너 런타임
2. API 서버와 통신하고 노드의 컨테이너를 관리하는 **`Kubelet`**
3. 애플리케이션 구성 요소간에 네트워크 트래픽을 로드밸런싱하는 **`쿠버네티스 서비스 프록시`**
   <br>
   <br>

### 쿠버네티스 애플리케이션의 실행

---

1. 애플리케이션을 하나 이상의 `컨테이너 이미지`로 패키징
2. 해당 이미지를 `이미지 레지스트리`로 푸시
3. 쿠버네티스 `API 서버`에 애플리케이션 `description`을 게시

<br>
<br>

### `Description` 으로 컨테이너를 실행하는 방법

---

1. `스케줄러`는 각 컨테이너에 필요한 리소스를 계산하고 해당 시점에 각 노드에 할당되지 않은 리소스를 기반으로 사용가능한 워커 노드에 지정된 컨테이너를 할당
2. 해당 노드의 `Kubelet`은 `컨테이너 런타임`에 필요한 컨테이너 이미지를 가져와 컨테이너를 실행하도록 지시
3. 애플리케이션이 실행되면 쿠버네티스는 애플리케이션의 배포상태가 사용자가 제공한 `Description`과 일치하는지 지속적으로 확인
4. 이때, 워커 노드 전체가 종료되거나 액세스할 수 없게 되면 쿠버네티스는 이 노드에서 실행 중인 모든 컨테이너의 노드를 새로 스케줄링하고, 새로 선택한 노드에서 실행

<br>
<br>

### 쿠버네티스 사용의 장점

---

1. 애플리케이션 배포의 단순화
2. 하드웨어 활용도 높이기
   1. 애플리케이션을 특정 노드로 지정하지 않으면 언제든지 애플리케이션이 클러스터 간에 자유롭게 이동할 수 있으므로 클러스터에서 실행되는 다른 애플리케이션 구성 요소를 혼합해 클러스터 노드에 배치할 수 있다. 따라서 노드의 하드웨어 리소스를 최대한 활용할 수 있다.
3. 상태확인과 자가치유
   1. 노드 장애 발생 시 자동으로 애플리케이션을 다른 노드로 스케줄링
4. 오토스케일링
   1. 쿠버네티스는 각 애플리케이션에서 사용하는 리소스를 모니터링하고 각 애플리케이션의 실행 중인 인스턴스 수를 계속 조정하고 지시 가능
   2. 클라우드 인프라에서 쿠버네티스가 실행 중인 경우 클라우드 제공업체의 API로 쉽게 노드를 추가하면 배포된 애플리케이션의 부하에 따라 전체 클러스터 크기를 자동으로 확장하거나 축소
5. 애플리케이션 개발 단순화
   1. 클러스터된 애플리케이션에서 서비스나 피어를 검색하는 기능 구현을 쿠버네티스가 수행
